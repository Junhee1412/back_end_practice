### 21. NOT NULL

- 데이터가 반드시 INSERT되어야 함. 없으면 오류가 발생
- UPDATE 구문 확인하기
UPDATE 테이블명 SET 컬럼명=변경 할 데이터 WHERE 조건;

---

### 22. FK참조 제약조건

- FK가 참조되어 ON DELETE SET NULL 일 경우에는 해당 컬럼이 지워질 때 NULL 되는 값을 주의깊게 봐야한다.
- NULL이 되면 안되는 경우(PK, NOT NULL) ON DELETE SET NULL을 이용하여 컬럼이 삭제되면 오류가 발생한다.
- 보기에 있는 쿼리문을 순서대로 실행했다는 생각은 하면 안됨.

---



### 23, 25, 26. TRUNCATE, DELETE, DROP

#### DROP

- 테이블을 없었던 것으로 만들고 자동 COMMIT

#### TRUNCATE

- 테이블만 두고 데이터를 모두 지운 뒤 자동 COMMIT

#### DELETE

- 데이터를 지우고 ROLLBACK 가능 상태로 사용자가 COMMIT하지 않으면 ROLLBACK 가능

---

### 24. DISTINCT

- 문제에서 어떤 결과를 도출해냈는지 파악하면 쉬운 문제
- 중복된 데이터를 제외하는 것은 DISTINCT 명령어를 입력하면된다.

---

### 27, 28. 데이터베이스 트랜잭션

#### 데이터 트랜잭션의 성격

1) 원자성(atomicity) : 트랜잭션이 DB에 모두 반영이 되거나 아예 반영되어선 안된다.
2) 일관성(consistency) : 트랜잭션의 작업 처리 결과는 항상 일관성 있어야 한다.
3) 고립성(isolation) : 두 가지 이상의 트랜잭션이 동시에 병행되어 있을 때 어떠한 트랜잭션도 다른 트랜잭션의 연산에 끼어들 수 없다. 고립되어 실행된다.
4) 영속성, 지속성(durability) : 트랜잭션이 성공적으로 완료되었을 때 결과는 영구적으로 반영되어야 한다.

#### 데이터 트랜잭션의 격리수준

1) SERIALIZABLE(직렬화 가능)
2) REPEATABLE READ(반복 가능한 읽기)
3) READ COMMITTED(커밋된 읽기)
4) READ UNCOMITTED(커밋되지 않은 읽기)

아래로 내려갈 수록 격리 수준이 낮아지며 동시처리 성능은 높아지는데 데이터 부정합 문제가 발생할 확률이 증가한다.
즉, 데이터 정합성과 성능은 반비례한다.

#### 데이터 트랜잭션 격리수준에 따라 발생할 수 있는 문제점

1) Dirty Read(더티 리드)
 - 특정 트랜잭션에 의해 데이터가 변경되었으나 커밋되지 않은 상황에서 다른 트랜잭션이 해당 변경 사항을 조회할 수 있는 문제를 뜻한다.
 - 트랜잭션 A가 실행되었고 트랜잭션 B가 A의 변경사항을 읽었다. 그러나 트랜잭션 A가 커밋되지 않은채로 B가 읽었고 A가 ROLLBACK할 경우에 B는 잘못된 데이터를 읽고 처리하므로 치명적이다.
 
2) Non-Repeatable Read(반복 불가능한 조회)
 - 같은 트랜잭션 내에서 같은 데이터를 여러번 조회하는데 읽어온 데이터가 다른 경우를 뜻한다.
 
3) Phantom Read(팬텀 리드)
 - Non-Repeatable Read의 한 종류로 조회한 결과의 행이 새로 생기거나 없어지는 현상을 뜻한다.
 
---

### 29. Oracle과 SQL Server Commit차이

- Oracle은 Create Table(DDL)을 실행하면 COMMIT이 실행된다.
- SQL Server는 DDL이 실행되어도 COMMIT을 명시하지 않으면 COMMIT이 진행되지 않는다.
- ROLLBACK했을 때 어떤 데이터를 읽어들이는지 중요

---

### 30. 트랜잭션 설명

- 데이터베이스의 논리적 연산단위
- 분리될 수 없는 한 개 이상의 데이터베이스 조작
- 변경 사항을 영구 반영하는 COMMIT
- 변경 사항을 모두 폐기하고 변경 전 상태로 되돌리는 ROLLBACK이 있다.

---

### 31, 32. COMMIT, ROLLBACK

- 트랜잭션의 이름이 명시되어 있고 해당 트랜잭션만 COMMIT 할 수 있다.
- ROLLBACK 명령어가 그냥 실행되면 COMMIT 직후 모든 트랜잭션을 무효한다.
- BEGIN TRANSACTION; SAVE TRANSACTION 트랜잭션명;
- ROLLBACK TRANSACTION 트랜잭션명;

---

### 33, 34. WHERE

- 조건을 입력할 수 있는 명령어는 WHERE 조건절이다.
- WHERE 조건에는 논리연산자로 NOT, AND, OR을 쓸 수 있는데 NOT, AND, OR 순으로 우선 적용된다.

---

### 35, 36, 37. NULL

- NULL은 비교하거나 조건문에 사용될 때 IS NULL, IS NOT NULL로 사용되어진다.
- NULL+x는 모두 NULL이다.
- NULL은 모르는 값이다. 모르는 값에 어떠한 연산자를 붙여도 모르는 값에 더하고 빼고 곱해도 그 값은 알 수 없다. 즉, NULL로 반환된다.
- 공백도 값이다. '';로 데이터를 입력한다면 그건 NULL이 아니라 공백이라는 값이다.

---

### 38, 39. BETWEEN

- 값의 사잇값을 뜻한다.
- 조건문에 쓰이며 AND와 OR과 함께 쓰일 수 있다.
- 기간이나 숫자 값, 포함, 초과 등을 고려해서 문제 풀 것

---


### 40. 단일행 함수, 다중행 함수

#### 단일행 함수

- 단일행 함수는 함수의 입력 행수에 따라 구분한다.
- 단일행 함수는 1개의 결과 값을 도출한다.
- 각 행에 대한 조작결과를 리턴한다.
- 5개를 입력하면 5개가 출력된다.
- 단일행 함수는 SELECT, WHERE, ORDER BY, UPDATE의 SET절에 사용 가능하다.
- 1:M 조인이라 하더라도 M쪽에서 출력된 행이 하나씩 단일행 함수의 입력값으로 사용되므로 사용할 수 있음.
- lower, upper, substr, length, trim, replace가 있다.

#### 다중행 함수

- 함수의 입력 행수가 여러개
- 여러 행을 바탕으로 1개의 결과값을 도출한다.
- 5개를 입력해도 1개가 값으로 출력된다.
- 여러행이 결과로 나오는 열은 사용이 불가능하다.
- sum, count, max, min, avg가 있다.