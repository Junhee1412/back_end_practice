## 디자인 패턴

- 개발 과정 중에 문제가 발생하면 새로 해결책을 구상하는 것보다 문제에 해당하는 디자인 패턴을 참고하여 적용하는 것이 더 효율적이다.
- 1995년 GoF라고 불리는 집단이 처음으로 구체화 및 체계화하였다.
- GoF 디자인 패턴은 생성 패턴 5개, 구조 패턴 7개, 행위 패턴 11개 총 23개의 패턴으로 구성되어 있다.

---

### 디자인 패턴의 장 단점

- 범용적인 코딩 스타일로 구조 파악이 용이하다.
- 객체지향 설계 및 구현의 생산성을 높이는 데 적합하다.
- 검증된 구조의 재사용을 통해 개발 시간과 비용이 절약된다.
- 초기 투자 비용이 부담될 수 있다.
- 객체지향을 기반으로 한 설계와 구현을 다루므로 다른 기반의 애플리케이션 개발에 적합하지 않다.

---

### 생성 패턴

- 추상 팩토리(Abstract Factory) : 구체적인 클래스에 의존하지 않고 연관, 의존하는 객체들을 묶어 그룹으로 생성, 추상적으로 표현한다.
- 빌더(Builder) : 작게 분리된 인스턴스를 건축 하듯이 조합하여 객체를 생성
- 팩토리 메소드(Factory Method) : 가상 생성자 패턴이라고도 한다. 상위 클래스에선 인터페이스만 정의하고 실제 생성은 서브 클래스가 담당한다.
- 프로토타입(Prototype) : 원본 객체를 복제하는 방법으로 객체를 생성하는 패턴이다.
- 싱글톤(Singleton) : 하나의 객체를 생성하면 생성된 객체를 어디서든 참조할 수 있지만, 여러 프로세스가 동시에 참조할 수는 없다.

---

### 구조 패턴

- 어댑터(Adapter) : 호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 변환해주는 패턴
- 브리지(Bridge) : 구현부에서 추상층을 분리하여, 서로가 독립적으로 확장할 수 있도록 구성한 패턴
- 컴포지트(Composite) : 여러 객체를 가진 복합 객체와 단일 객체를 구분 없이 다루고자 할 때 사용하는 패턴
- 데코레이터(Decorator)
- 퍼싸드(Facade)
- 플라이 웨이트(Flyweight)
- 프록시(Proxy) : 네트워크 연결, 메모리의 대용량 객체로의 접근 등에 주로 이용한다.

---

### 행위 패턴

- 책임 연쇄(Chain of Responsibility) : 요청처리할 수 있는 객체가 둘 이상 존재, 한 객체가 처리하지 못하면 다음 객체로 넘어간다.
- 커맨드(Command) : 요청을 객체의 형태로 캡슐화하여 재이용하거나 취소할 수 있도록 필요한 정보를 저장하거나 로그에 남긴다.
- 인터프리터(Interpreter) : 언어에 문법 표현을 정의하는 패턴
- 반복자(Iterator) : 자료 구조와 같이 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴
- 중재자(Mediator) : 수많은 객체들 간의 복잡한 상호작용을 캡슐화하여 객체로 정의하는 패턴이다.
- 메멘토(memento) : 객체를 해당 시점의 상태로 돌릴 수 있는 기능을 제공하는 패턴
- 옵서버(Observer) : 객체의 상태가 변화하면 객체에 상속되어 있는 다른 객체들에게 변화된 상태를 전달
- 상태(State) : 객체의 상태에 따라 동일한 동작을 다르게 처리해야 할 때 사용
- 전략(Strategy) : 동일한 계열의 알고리즘들을 개별적으로 캡슐화하여 상호 교환할 수 있게 정의하는 패턴
- 템플릿 메소드(Template Method) : 상위 클래스에서 골격을 정의하고 하위 클래스에서 세부 처리 구체화하는 구조의 패턴
- 방문자(Visitor) : 각 클래스들의 데이터 구조에서 처리 기능을 분리하여 별도의 클래스로 구성하는 패턴
